import os
import re
import pandas as pd
from dotenv import load_dotenv
from sqlalchemy import create_engine, text
import streamlit as st

# ----------------- Load Environment -----------------
load_dotenv()
DATABASE_URL = os.getenv("DATABASE_URL")

# ----------------- Clean SQL Function -----------------
def clean_sql(query: str) -> str:
    """
    Cleans and fixes SQL generated by the Hugging Face model
    for the `users` table with columns: id, name, email, signup_date.
    """
    # Force correct table name
    query = re.sub(r"\btable\b", "users", query, flags=re.IGNORECASE)

    # Synonyms mapping for columns
    synonyms = {
        "User": "name",
        "Signed": "signup_date",
        "Sign": "signup_date",
        "Signup": "signup_date",      # ‚úÖ Force map signup ‚Üí signup_date
        "SignupDate": "signup_date",
        "Date": "signup_date",
        "ID": "id",
        "Details": "*"               # convert SELECT Details ‚Üí SELECT *
    }

    # Replace synonyms in query
    for wrong, right in synonyms.items():
        query = re.sub(rf"\b{wrong}\b", right, query, flags=re.IGNORECASE)

    # Expand SELECT statements
    query = re.sub(r"SELECT\s+(Details|Name|Users?)", "SELECT *", query, flags=re.IGNORECASE)

    # Handle equality words
    query = re.sub(r"\b(on|at|equals|is)\b", "=", query, flags=re.IGNORECASE)

    # Handle comparison words
    query = re.sub(r"\bgreater than\b", ">", query, flags=re.IGNORECASE)
    query = re.sub(r"\bless than\b", "<", query, flags=re.IGNORECASE)
    query = re.sub(r"\bgreater or equal\b", ">=", query, flags=re.IGNORECASE)
    query = re.sub(r"\bless or equal\b", "<=", query, flags=re.IGNORECASE)

    # Wrap string literals in single quotes
    def quote_values(match):
        lhs, rhs = match.group(1), match.group(2)
        if rhs.isdigit():
            return f"{lhs}{rhs}"
        return f"{lhs}'{rhs}'"
    query = re.sub(r"(WHERE\s+\w+\s*=\s*)(\w+)", quote_values, query, flags=re.IGNORECASE)

    # Remove meaningless WHERE clauses 
    query = re.sub(r"WHERE\s+name\s*=\s*'users'", "", query, flags=re.IGNORECASE)

    # Wrap dates in quotes
    query = re.sub(r"(\d{4}-\d{2}-\d{2})", r"'\1'", query)

    # ‚úÖ Handle ORDER BY ascending/descending
    order_match = re.search(r"sorted by (\w+)( ascending| descending)?", query, flags=re.IGNORECASE)
    if order_match:
        col_nl = order_match.group(1)
        # Map column name properly using synonyms
        column = synonyms.get(col_nl.capitalize(), col_nl)
        direction_nl = order_match.group(2)
        if direction_nl:
            direction_nl = direction_nl.strip().upper()
            direction = "DESC" if direction_nl == "DESCENDING" else "ASC"
        else:
            direction = "ASC"  # Default ascending if not specified

        # Remove leftover "sorted by ..." text
        query = re.sub(r"(WHERE\s+.*sorted by.*|sorted by.*)", "", query, flags=re.IGNORECASE)
        query = f"{query.strip()} ORDER BY {column} {direction}".strip()

    # Clean extra spaces and ensure correct table reference
    query = re.sub(r"\s+", " ", query).strip()
    query = re.sub(r"FROM\s+\w+", "FROM users", query, flags=re.IGNORECASE)

    return query

# ----------------- Run Query Function -----------------
def run_query(sql_query):
    engine = create_engine(DATABASE_URL)
    with engine.connect() as conn:
        result = conn.execute(text(sql_query))
        rows = result.fetchall()
        columns = result.keys()
        return pd.DataFrame(rows, columns=columns)

# ----------------- Hugging Face Model Loader -----------------
@st.cache_resource(show_spinner=False)
def load_model():
    from transformers import pipeline
    return pipeline("text2text-generation", model="mrm8488/t5-base-finetuned-wikiSQL")

# ----------------- Natural-to-SQL Function -----------------
def natural_to_sql(question: str, nl2sql_model) -> str:
    prompt = "translate to SQL: " + question
    result = nl2sql_model(prompt, max_new_tokens=128, do_sample=False)
    raw_sql = result[0]["generated_text"]
    fixed_sql = clean_sql(raw_sql)
    return fixed_sql

# ----------------- Streamlit UI -----------------
st.set_page_config(page_title="YB's AI-Powered SQL Helper", page_icon="üíª", layout="centered")

st.title(" YB's AI-Powered SQL Helper")
st.markdown("### Built with **Neon (Postgres)** + **Hugging Face Transformers**")

question = st.text_input(
    "üí¨ Ask your question in natural language:",
    placeholder="e.g., Show all users sorted by signup date descending"
)

if st.button("üöÄ Run Query"):
    if not question.strip():
        st.warning("Please enter a question!")
    else:
        with st.spinner("Loading model and generating SQL‚Ä¶"):
            try:
                nl2sql_model = load_model()
                fixed_sql = natural_to_sql(question, nl2sql_model)

                st.subheader("üîπ Cleaned SQL")
                st.code(fixed_sql, language="sql")

                df = run_query(fixed_sql)
                if not df.empty:
                    st.subheader("üìä Query Results")
                    st.dataframe(df, use_container_width=True)
                else:
                    st.warning("‚ö†Ô∏è No results found.")
            except Exception as e:
                st.error(f"‚ùå Error: {e}")

st.markdown("---")
st.caption("Made with ‚ù§Ô∏è by **Yaaseen Basit** using Streamlit, Neon, and Hugging Face")
